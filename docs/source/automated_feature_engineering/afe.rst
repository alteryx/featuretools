.. _deep-feature-synthesis:
.. currentmodule:: featuretools

Deep Feature Synthesis
======================

Deep Feature Synthesis (DFS) is an automated method for performing feature engineering on relational and temporal data.


Input Data
***********

Deep Feature Synthesis requires structured datasets in order to perform feature engineering. To demonstrate the capabilities of DFS, we will use a mock customer transactions dataset.

.. note ::

  Before using DFS, it is recommended that you prepare your data as an :class:`EntitySet`.  See :doc:`/loading_data/using_entitysets` to learn how.


.. ipython:: python

    import featuretools as ft
    es = ft.demo.load_mock_customer(return_entityset=True)
    es

Once data is prepared as an :class:`.EntitySet`, we are ready to automatically generate features for a target entity - e.g. ``customers``.

Running DFS
***********

Typically, without automated feature engineering, a data scientist would write code to aggregate data for a customer, and apply different statistical functions resulting in features quantifying the customer's behavior. In this example, an expert might be interested in features such as: `total number of sessions` or `month the customer signed up`.

These features can be generated by DFS when we specify the target_entity as ``customers`` and ``"count"`` and ``"month"`` as primitives.


.. ipython:: python

    feature_matrix, feature_defs = ft.dfs(entityset=es,
                                          target_entity="customers",
                                          agg_primitives=["count"],
                                          trans_primitives=["month"],
                                          max_depth=1)
    feature_matrix

In the example above, ``"count"`` is an **aggregation primitive** because it computes a single value based on many sessions related to one customer. ``"month"`` is called a **transform primitive** because it takes one value for a customer transforms it to another.


.. note ::

  Feature primitives are a fundamental component to Featuretools. To learn more read :doc:`/automated_feature_engineering/primitives`.


Creating "Deep Features"
************************

The name Deep Feature Synthesis comes from the algorithm's ability to stack primitives to generate more complex features. Each time we stack a primitive we increase the "depth" of a feature. The ``max_depth`` parameter controls the maximum depth of the features returned by DFS. Let us try running DFS with ``max_depth=2``

.. ipython:: python

    feature_matrix, feature_defs = ft.dfs(entityset=es,
                                          target_entity="customers",
                                          agg_primitives=["mean", "sum", "mode"],
                                          trans_primitives=["month", "hour"],
                                          max_depth=2)
    feature_matrix


With a depth of 2, a number of features are generated using the supplied primitives. The algorithm to synthesize these definitions is described in this `paper <http://www.jmaxkanter.com/static/papers/DSAA_DSM_2015.pdf>`_. In the returned feature matrix, let us understand one of the depth 2 features

.. ipython:: python

    feature_matrix[['MEAN(sessions.SUM(transactions.amount))']]

For each customer this feature

1. calculates the ``sum`` of all transaction amounts per session to get total amount per session,
2. then applies the ``mean`` to the total amounts across multiple sessions to identify the *average amount spent per session*

We call this feature a "deep feature" with a depth of 2.

Let's look at another depth 2 feature that calculates for every customer *the most common hour of the day when they start a session*

.. ipython:: python

    feature_matrix[['MODE(sessions.HOUR(session_start))']]

For each customer this feature calculates

1. The ``hour`` of the day each of his or her sessions started, then
2. uses the statistical function ``mode`` to identify the most common hour he or she started a session

Stacking results in features that are more expressive than individual primitives themselves. This enables the automatic creation of complex patterns for machine learning.

Changing Target Entity
**********************

DFS is powerful because we can create a feature matrix for any entity in our dataset. If we switch our target entity to "sessions", we can synthesize features for each session instead of each customer. Now, we can use these features to predict the outcome of a session.

.. ipython:: python

    feature_matrix, feature_defs = ft.dfs(entityset=es,
                                          target_entity="sessions",
                                          agg_primitives=["mean", "sum", "mode"],
                                          trans_primitives=["month", "hour"],
                                          max_depth=2)
    feature_matrix.head(5)

As we can see, DFS will also build deep features based on a parent entity, in this case the customer of a particular session. For example, the feature below calculates the mean transaction amount of the customer of the session.

.. ipython:: python

  feature_matrix[['customers.MEAN(transactions.amount)']].head(5)

Improve feature output
~~~~~~~~~~~~~~~~~~~~~~
To learn about the parameters to change in DFS read :doc:`/guides/tuning_dfs`.


.. here it maybe nice to have a table that shows the number of features generated for AirBnB and other KAGGLE datasets once we have them. We can also give the user access to it.
